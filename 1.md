# pintos loader and kernel initialization

- threads/loader.S
    - stored in first sector of the hard disk for pc bios to load
    - PC BIOS loads loader --> loader loads kernel at 0x7c00-0x7e00 (512 bytes)
    - and jumps to to entry point - start.S


    - pc bios loads the loader from MBR
    - memory usage
        - 64 bytes - MBR partition table
        - 128 bytes for kernel cmd args
        - ~300 bytes for loader code

    - 300 bytes is tight, therefore we need assembly


## loader.S -> load kernel -> transfer control to start.S


# process

t0 : submitted job 
ti : start exec
tp : output 

t0-----ti=========tp 


waiting time : ti - t0
turnaround time : tp - t0 


- what we need?
    - minimize waiting and turnaround time





JOB    EXEC TIME

J1  --> 15
J2      8
J3      10
J4      3


### FCFS scheduling

- jobs arrived in sequence

- CASE 

0   
|----j1----|----j2----|-----j3----|----j4---|

    15          8           10          3

    Wj1 = 0 : waiting time of j1
    Wj2 = 15
    Wj3 = 23
    Wj4 = 33
    Tw = 71

    AvgWait = 17.75




### SJF scheduling
- lets change the sequence:
- we dont care how they arrive
- we care how they are exec

- put em in the queue


|----j4----|----j2----|-----j3----|----j1---|

     3          8           10         15

    Wj4 = 0 : waiting time of j4
    Wj2 = 3
    Wj3 = 11
    Wj1 = 21
    Tw = 35

    AvgWait = 8.75


- exec shorter jobs first




### process state diagram

single core - runs cant overlap


CPU burst : run : active
IO burst : io: waiting


A ---run---| io           || ready | ------ run ------| .
B ready    | --- run ------------- | io       | ready | -- run --|



                     cpu scheduler picks among the ready jobs

```
new -----> ready -----> active ------> halted
             |              |
             |              |
             |              |
             |              |
             + <--------- waiting

```
-----
## QUESTION : How TO KNOW ANYTHING ABOUT THE NEXT CPU BURST TIME?

- we need to predict it

- predictor
    - Tn+1 = (a)tn + (1-a)Tn
    - this calculation has to be VERY EFFICIENT
    - next predicted = (A)actual + (1-A)predicted  : this formula sorta self corrects the prediction error


    - Tn+1 predicted time of n+1
    - tn exact nth
    - Tn predicted nth



    - How to get T0? bruh

    - for the first time:
        - just do FCFS  

        assume,  T1 = t1
        T2 = a(t1) + (1-a)t1

        0 < a < 1



- so we do First come --> sjf

- RECAP : WE NEED THESE PREDICTED TIMES SO THAT WE CAN GRAB THE SHORTEST TIME JOB FROM THE ready QUEUE AND exec it


## PRIORITY SCHEDULING

- we specify priority
- SJF is special case of priority scheduling

```
    Pn(I) = 1/Tn+1(I)
```


#### Non preemptive scheduling
- Full cpu burst needs to occur before job goes into waiting

- FCFS
- SJF
- PRIORITY


#### preemptive scheduling
- sjf and priority could be modified

```

J1      15
J2      9
J3      3
J4      5

J3--2--|       J3--1--|J4--5---|
        J5--1--|
```

### SRT: Shortest Remaining Time 
```
when new job arrives:
        if new job priority > current job priority do
            wait current job
            set current job's new time remaining
            start new job
        
```


### Preemptive Priority

- at regular intervals of time, we increase the priority of jobs in the ready-queue

- FOR ALL PREEMPTIVE: new process state diagram

```
new -----> ready -----> active ------> halted
             |   <-----     |
             |              |
             |              |
             |              |
             + <--------- waiting

```


- CPU bound jobs
- IO bound jobs

- You dont want too many cpu jobs or too many io bound jobs. You want a mix in the ready queue.
- so that all the resources are utilized efficiently.


# 2 types of schedulers

- long term new -> ready
    - long term scheduler is responsible for the mix
    - can take a long time to decide

- short term ready -> active
    - cannot take long time to decide
